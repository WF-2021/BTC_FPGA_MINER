//	********************************************************************************
//	模块名：uart_rx
//	功  能：控制串口接收
//	资	源：
//	********************************************************************************
module uart_rx # (
	
	//	输入参数
	parameter	IS_SIM				= "TRUE"		,	//	是否为仿真测试，"TRUE" "FALSE"
	parameter	BAUD_RATE			= "115200"		,	//	波特率，"9600" "115200"
	parameter	UART_DATA_WID		= 8				,	//	串口数据位宽，8
	parameter	UART_RX_DATA_NUM	= 82				//	串口接收数据总个数，82
	)                                                       	
	(                                                       	
	                                                        	
	//	时钟复位信号                                        	
	input							clk				,	//	模块工作时钟信号
	input							rst				,	//	clk时钟域，复位

	//	串口信号     
	input							i_rx			,	//	异步时钟域，串口接收线
	output	[UART_DATA_WID	-1:0]	ov_rx_data		,	//	clk时钟域，串口接收数据
	output							o_rx_data_vld	,	//	clk时钟域，串口接收数据有效	
	output							o_rx_busy			//	clk时钟域，串口接收忙碌
	);
	
	
	//  ===============================================================================================
	//	参数、信号、函数说明
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	函数说明
	//  -------------------------------------------------------------------------------------
	//	-----------------------------------------------------------------
	//	求数据位宽
	//	例如16的位宽是4，log2(16)=4
	//	-----------------------------------------------------------------
	function integer log2;
		
		//	输入信号
		input	integer	data;
		
		//	参数声明 
		integer data_tmp;
		
		//	运算过程  
		begin
			data_tmp = data - 1;
			for (log2=0; data_tmp>0; log2=log2+1) begin
				data_tmp = data_tmp >> 1;
			end
		end
	endfunction
	
	//  -------------------------------------------------------------------------------------
	//	参数说明
	//  -------------------------------------------------------------------------------------
//	//	175MHz
//	localparam	BAUD_RATE_CNT_NUM		= (IS_SIM	 == "TRUE"	) ? 10		:
//										  (BAUD_RATE == "115200") ? 1519	: 
//										  (BAUD_RATE == "9600"  ) ? 18229	: 18229	;	//	波特率计数器计数个数
	
	//	100MHz
	localparam	BAUD_RATE_CNT_NUM		= (IS_SIM	 == "TRUE"	) ? 10		:
										  (BAUD_RATE == "115200") ? 868		: 
										  (BAUD_RATE == "9600"  ) ? 10416	: 10416	;	//	波特率计数器计数个数
	localparam	BAUD_RATE_CNT_WID		= log2(BAUD_RATE_CNT_NUM)					;	//	波特率计数器位宽
	localparam	HALF_BAUD_RATE_CNT_NUM	= BAUD_RATE_CNT_NUM / 2						;	//	半波特率计数器计数个数
	localparam	BIT_CNT_NUM				= UART_DATA_WID + 2							;	//	bit计数器计数个数
	localparam	BIT_CNT_WID				= log2(BIT_CNT_NUM)							;	//	bit计数器位宽
	localparam	BYTE_CNT_NUM			= UART_RX_DATA_NUM							;	//	byte计数器计数个数
	localparam	BYTE_CNT_WID			= log2(BYTE_CNT_NUM)						;	//	byte计数器位宽
	
	//  -------------------------------------------------------------------------------------
	//	信号说明
	//  -------------------------------------------------------------------------------------
	//	辅助信号	
	reg		[3					-1:0]	rx_dly			= 3'b111;	//	clk时钟域，串口接收线，打1拍	
	wire								rx_fall					;	//	clk时钟域，串口接收线，下降沿
	
	//	串口信号
	reg									rx_en			= 1'b0	;	//	clk时钟域，串口接收使能
	reg		[BAUD_RATE_CNT_WID	-1:0]	baud_rate_cnt	= 'b0	;	//	clk时钟域，波特率计数器
	reg		[BIT_CNT_WID		-1:0]	bit_cnt			= 'b0	;	//	clk时钟域，bit计数器
	reg		[BYTE_CNT_WID		-1:0]	byte_cnt		= 'b0	;	//	clk时钟域，byte计数器
	reg		[UART_DATA_WID		-1:0]	rx_data			= 'b0	;	//	clk时钟域，串口接收数据
	reg									rx_busy			= 1'b0	;	//	clk时钟域，串口接收忙碌
	
		
	//  ===============================================================================================
	//	辅助信号
	//  ===============================================================================================	
	//  -------------------------------------------------------------------------------------
	//	信号打拍
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		rx_dly <= {rx_dly, i_rx};
	end
	
	//  -------------------------------------------------------------------------------------
	//	信号上升、下降沿
	//  -------------------------------------------------------------------------------------
	assign rx_fall = ((rx_dly[1] == 1'b0) && (rx_dly[2] == 1'b1)) ? 1'b1 : 1'b0;
	
	
	//  ===============================================================================================
	//	串口发送
	//  ===============================================================================================	
	//  -------------------------------------------------------------------------------------
	//	串口接收使能
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	串口接收线下降沿，使能
		if(rx_fall == 1'b1) begin
			rx_en <= 1'b1;
		end
		
		//	在串口接收完一个byte时，置低
		else if((rx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) && (bit_cnt == (BIT_CNT_NUM - 1'b1))) begin
			rx_en <= 1'b0;
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	串口波特率计数器
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	发送使能有效时，计数
		if(rx_en == 1'b1) begin
			
			//	计到最大值，清零
			if(baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) begin
				baud_rate_cnt <= 'b0;
			end
			
			//	否则，累加一
			else begin
				baud_rate_cnt <= baud_rate_cnt + 1'b1;
			end
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	bit计数器
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	发送使能有效，且波特率计数器计到最大值时，计数
		if((rx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1))) begin
			
			//	计到最大值，清零
			if(bit_cnt == (BIT_CNT_NUM - 1'b1)) begin
				bit_cnt <= 'b0;
			end
			
			//	否则，累加一
			else begin
				bit_cnt <= bit_cnt + 1'b1;
			end
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	byte计数器
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	发送使能有效，且bit计数器计到最大值时，计数
		if((rx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) && (bit_cnt == (BIT_CNT_NUM - 1'b1))) begin
			
			//	计到最大值，清零
			if(byte_cnt == (BYTE_CNT_NUM - 1'b1)) begin
				byte_cnt <= 'b0;
			end
			
			//	否则，累加一
			else begin
				byte_cnt <= byte_cnt + 1'b1;
			end
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	串口接收数据
	//	起始位0 + LSB + MSB + 停止位1
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	根据bit计数器，在半波特率处锁存串口接收线
		if((rx_en == 1'b1) && (baud_rate_cnt == (HALF_BAUD_RATE_CNT_NUM - 1'b1)) && ((bit_cnt != 'b0) && (bit_cnt != (BIT_CNT_NUM - 1'b1)))) begin
			rx_data <= {i_rx, rx_data[UART_DATA_WID-1 : 1]};
		end
	end
	
	assign ov_rx_data = rx_data;
	
	//  -------------------------------------------------------------------------------------
	//	串口接收数据有效
	//	接收使能有效，且bit计数器计到最大值时，置高
	//  -------------------------------------------------------------------------------------
	assign o_rx_data_vld = ((rx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) && (bit_cnt == (BIT_CNT_NUM - 1'b1))) ? 1'b1 : 1'b0;	
	
	//  -------------------------------------------------------------------------------------
	//	串口接收忙碌
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	在串口接收线下降沿处，置高
		if(rx_fall == 1'b1) begin
			rx_busy <= 1'b1;
		end
		
		//	接收使能有效，且byte计数器计到最大值时，置低
		else if((rx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) && (bit_cnt == (BIT_CNT_NUM - 1'b1)) && (byte_cnt == (BYTE_CNT_NUM - 1'b1))) begin
			rx_busy <= 1'b0;
		end
	end
	
	assign o_rx_busy = rx_busy;
	
endmodule