//	********************************************************************************
//	模块名：uart_tx
//	功  能：控制串口发送
//	资	源：
//	********************************************************************************
module uart_tx # (
	
	//	输入参数
	parameter		IS_SIM			= "TRUE"		,	//	是否为仿真测试，"TRUE" "FALSE"
	parameter		BAUD_RATE		= "115200"		,	//	波特率，"9600" "115200"
	parameter		UART_DATA_WID	= 8					//	串口数据位宽，8
	)                                                       	
	(                                                       	
	                                                        	
	//	时钟复位信号                                        	
	input							clk				,	//	模块工作时钟信号
	input							rst				,	//	clk时钟域，复位
	                                                	
	//	串口信号                                    	
	input	[UART_DATA_WID	-1:0]	iv_tx_data		,	//	clk时钟域，串口发送数据
	input							i_tx_data_vld	,	//	clk时钟域，串口发送数据有效
	output							o_tx			,	//	clk时钟域，串口发送线
	output							o_tx_done			//	clk时钟域，串口发送完成
	);
	
	
	//  ===============================================================================================
	//	参数、信号、函数说明
	//  ===============================================================================================
	//  -------------------------------------------------------------------------------------
	//	函数说明
	//  -------------------------------------------------------------------------------------
	//	-----------------------------------------------------------------
	//	求数据位宽
	//	例如16的位宽是4，log2(16)=4
	//	-----------------------------------------------------------------
	function integer log2;
		
		//	输入信号
		input	integer	data;
		
		//	参数声明 
		integer data_tmp;
		
		//	运算过程  
		begin
			data_tmp = data - 1;
			for (log2=0; data_tmp>0; log2=log2+1) begin
				data_tmp = data_tmp >> 1;
			end
		end
	endfunction
	
	//  -------------------------------------------------------------------------------------
	//	参数说明
	//  -------------------------------------------------------------------------------------
	//	//	175MHz
//	localparam	BAUD_RATE_CNT_NUM	= (IS_SIM	 == "TRUE"	) ? 10		:
//									  (BAUD_RATE == "115200") ? 1519	: 
//									  (BAUD_RATE == "9600"  ) ? 18229	: 18229	;	//	波特率计数器计数个数
	
	//	100MHz
	localparam	BAUD_RATE_CNT_NUM	= (IS_SIM	 == "TRUE"	) ? 10		:
									  (BAUD_RATE == "115200") ? 868		: 
									  (BAUD_RATE == "9600"  ) ? 10416	: 10416	;	//	波特率计数器计数个数
	localparam	BAUD_RATE_CNT_WID	= log2(BAUD_RATE_CNT_NUM)					;	//	波特率计数器位宽
	localparam	BIT_CNT_NUM			= UART_DATA_WID + 2							;	//	bit计数器计数个数
	localparam	BIT_CNT_WID			= log2(BIT_CNT_NUM)							;	//	bit计数器位宽
	
	//  -------------------------------------------------------------------------------------
	//	信号说明
	//  -------------------------------------------------------------------------------------
	//	串口信号
	reg		[UART_DATA_WID		-1:0]	tx_data			= 'b0	;	//	clk时钟域，串口发送数据
	reg									tx_en			= 1'b0	;	//	clk时钟域，串口发送使能
	reg		[BAUD_RATE_CNT_WID	-1:0]	baud_rate_cnt	= 'b0	;	//	clk时钟域，波特率计数器
	reg		[BIT_CNT_WID		-1:0]	bit_cnt			= 'b0	;	//	clk时钟域，bit计数器
	reg									tx						;	//	clk时钟域，串口发送线
	
		
	//  ===============================================================================================
	//	串口发送
	//  ===============================================================================================	
	//  -------------------------------------------------------------------------------------
	//	串口发送数据锁存
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	在串口发送数据有效时，锁存发送数据
		if(i_tx_data_vld == 1'b1) begin
			tx_data <= iv_tx_data;
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	串口发送使能
	//	即使FPGA复位，也应将数据完整发送给PC，以防止PC卡死
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	在串口发送数据有效时，发送使能
		if(i_tx_data_vld == 1'b1) begin
			tx_en <= 1'b1;
		end
		
		//	在串口发送完成时，置低
		else if((tx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) && (bit_cnt == (BIT_CNT_NUM - 1'b1))) begin
			tx_en <= 1'b0;
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	串口波特率计数器
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	发送使能有效时，计数
		if(tx_en == 1'b1) begin
			
			//	计到最大值，清零
			if(baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) begin
				baud_rate_cnt <= 'b0;
			end
			
			//	否则，累加一
			else begin
				baud_rate_cnt <= baud_rate_cnt + 1'b1;
			end
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	bit计数器
	//  -------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		
		//	发送使能有效，且波特率计数器计到最大值时，计数
		if((tx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1))) begin
			
			//	计到最大值，清零
			if(bit_cnt == (BIT_CNT_NUM - 1'b1)) begin
				bit_cnt <= 'b0;
			end
			
			//	否则，累加一
			else begin
				bit_cnt <= bit_cnt + 1'b1;
			end
		end
	end
	
	//  -------------------------------------------------------------------------------------
	//	串口发送线
	//	起始位0 + LSB + MSB + 停止位1
	//  -------------------------------------------------------------------------------------
	always @ ( * ) begin
		
		//	发送期间
		if(tx_en == 1'b1) begin
			
			//	根据bit_cnt，选择tx_data对应的bit发送
			case(bit_cnt)
					
				//	起始位0
				'd0	: begin
					tx = 1'b0;
				end
				
				//	tx_data的bit0-7
				'd1	,
				'd2	,
				'd3	,
				'd4	,
				'd5	,
				'd6	,
				'd7	,
				'd8	: begin
					tx = tx_data[bit_cnt-1'b1];
				end
				
				//	停止位1
				'd9	: begin
					tx = 1'b1;
				end
				
				//	其余状态保持为1
				default	: begin
					tx = 1'b1;
				end
			endcase
		end
		
		//	非发送期间，保持高
		else begin
			tx = 1'b1;
		end
	end
	
	assign o_tx = tx;
	
	//  -------------------------------------------------------------------------------------
	//	串口发送完成
	//	发送使能有效，且bit计数器计到最大值时，置高
	//  -------------------------------------------------------------------------------------
	assign o_tx_done = ((tx_en == 1'b1) && (baud_rate_cnt == (BAUD_RATE_CNT_NUM - 1'b1)) && (bit_cnt == (BIT_CNT_NUM - 1'b1))) ? 1'b1 : 1'b0;	
	
endmodule